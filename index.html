<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BP Is Down!! ‚Äì Outage Funboard</title>
  <meta name="description" content="Big Purple outage funboard" />
  <style>
    :root{
      --bg:#c8a8e9; /* The background colour of the page */
      --panel:rgba(255,255,255,0.15); /* Panel is the background color of the card */
      --panel-border:rgba(255,255,255,0.25); /* Semi transparant card in the background is the colour of the card  */
      --text:#2d1b69; --muted:rgba(45,27,105,0.8); --muter:rgba(45,27,105,0.7);
      --purple-600:#7c3aed; /* The colour of the button (PURPLE)*/
      --socket-glow-1:rgba(168,85,247,0.6); /* The glow of the button when it is pressed */
      --socket-glow-2:rgba(168,85,247,0.28); /* The glow of the button when it is not pressed */
      --socket-glow-3:rgba(168, 37, 37, 0.85); /* The glow of the button when it is pressed */
      --socket-glow-4:rgba(151, 30, 30, 0.55); /* The glow of the button when it is not pressed */
      --stress-duration: 2s;
    } /* The glow of the button when it is not pressed */
    *{box-sizing:border-box} html,body{height:100%} 
    /* The body is the background colour of the page */
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:var(--bg);color:var(--text)}
    .page{min-height:100vh;display:flex;flex-direction:column}

    /* ASCII background animation (happy state) */
    .ascii-bg{position:fixed;inset:0;z-index:0;pointer-events:none;overflow:hidden;opacity:0.2}
    .ascii-tiles{position:absolute;inset:-10%;display:grid;grid-template-columns:repeat(6, minmax(220px, 1fr));gap:32px;transform:scale(1.05)}
    .ascii-tile{margin:0;white-space:pre;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:12px;line-height:12px;color:var(--text);animation:dance 3.2s ease-in-out infinite}
    .ascii-tile:nth-child(3n){animation-duration:3.8s}
    .ascii-tile:nth-child(4n){animation-duration:2.9s}
    .ascii-tile:nth-child(5n){animation-duration:4.2s}
    @keyframes dance{0%{transform:translateY(0) rotate(0)}50%{transform:translateY(6px) rotate(0.3deg)}100%{transform:translateY(0) rotate(0)}}

    /* Broken ASCII background animation (down state) */
    .ascii-broken{position:fixed;inset:0;z-index:0;pointer-events:none;overflow:hidden;opacity:0.15}
    .ascii-broken-tiles{position:absolute;inset:-10%;display:grid;grid-template-columns:repeat(6, minmax(220px, 1fr));gap:32px;transform:scale(1.05)}
    .ascii-broken-tile{margin:0;white-space:pre;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:12px;line-height:12px;color:rgb(255, 241, 164);animation:brokenDance 2.8s ease-in-out infinite}
    .ascii-broken-tile:nth-child(3n){animation-duration:3.2s}
    .ascii-broken-tile:nth-child(4n){animation-duration:2.1s}
    .ascii-broken-tile:nth-child(5n){animation-duration:3.6s}
    @keyframes brokenDance{0%{transform:translateY(0) rotate(0) scale(1)}25%{transform:translateY(-3px) rotate(-1deg) scale(0.98)}50%{transform:translateY(2px) rotate(1deg) scale(1.02)}75%{transform:translateY(-1px) rotate(-0.5deg) scale(0.99)}100%{transform:translateY(0) rotate(0) scale(1)}}
    .container{max-width:clamp(320px, 100vw, 1100px);margin:0 auto;padding:16px;width:100%}
    .banner{position:sticky;top:0;z-index:50}
    .card{background:rgba(124,58,237,0.10);border:1px solid var(--panel-border);border-radius:16px;padding:clamp(12px, 2vw, 1px)}
    .hush{color:var(--muted);font-size:12px;letter-spacing:.18em;text-transform:uppercase}
    .time{font-weight:800;font-variant-numeric:tabular-nums;font-size:clamp(28px,5vw,56px)}
    .muted{color:var(--muted);font-size:14px}
    .pill{background:rgba(255,255,255,0.08);border:1px solid var(--panel-border);border-radius:9999px;padding:6px 10px;font-size:12px;cursor:pointer}
    .center{position:fixed;
            top:calc(50vh + clamp(60px, 8vh, 120px)); /* The position of the button in relation to the container*/
            left:50%;transform:translate(-50%,-50%);
            display:flex;
            align-items:center;
            justify-content:center;
            padding:0;background:transparent;border:0;box-shadow:none;z-index:10}
            
    .socket{position:relative;background:transparent;border:none;box-shadow:none}

    /* --- Giant button --- */
    .btn-wrap{position:relative;outline:none;border:none;background:transparent;padding:0;box-shadow:none;transition:all .15s cubic-bezier(.4,0,.2,1);border-radius:50%}
    .btn-cap{
      border-radius:50%;
      width: clamp(200px, 20vw, 400px); 
      height: clamp(200px, 20vw, 400px);
      display:flex;align-items:center;justify-content:center;
      background:rgba(124,58,237,0.78);border:1px solid rgba(255,255,255,0.3);
      color:white;font-weight:900;letter-spacing:.02em;box-shadow:inset 0 3px 6px rgba(255,255,255,0.2);
      position:relative;transform:translateY(0) scale(1);transition:all .15s cubic-bezier(.4,0,.2,1);
    }
    .btn-shine{position:absolute;inset:-3px;border-radius:50%;background:linear-gradient(to bottom,rgba(255,255,255,0.25),transparent);pointer-events:none;transition:opacity .12s ease}
    .subtext{position:absolute;left:50%;transform:translateX(-50%);bottom:-36px;color:var(--muted);font-size:14px;white-space:nowrap}
    .button-disabled{cursor:not-allowed}
    .btn-press{transform:translateY(28px) scale(0.985);box-shadow:0 0 28px var(--socket-glow-3), 0 0 80px var(--socket-glow-4) !important} /* The glow of the button when it is pressed */
    .btn-normal{transform:translateY(0) scale(1);box-shadow:0 0 44px var(--socket-glow-1), 0 0 140px var(--socket-glow-2)} /* The glow of the button when it is not pressed */

    /* Idle breathing (off while pressed/disabled) */
    @keyframes breathe { 0%{transform:translateY(0) scale(1)} 50%{transform:translateY(0) scale(1.015)} 100%{transform:translateY(0) scale(1)} }
    .btn-wrap:not(.btn-press):not(.button-disabled) .btn-cap{ animation:breathe 2.4s ease-in-out infinite; } /* The breathing animation of the button if it is not pressed and not disabled */

    /* Popup + wobble probably invisible but et's */
    .popup-enter{animation:popupEnter 1.32s cubic-bezier(.4,0,.2,1)}
    @keyframes popupEnter{from{opacity:0;transform:scale(.95) translateY(10px)}to{opacity:1;transform:scale(1) translateY(0)}}
    @keyframes wobble{0%{transform:rotate(-2deg) translateY(0)}50%{transform:rotate(2deg) translateY(2px)}100%{transform:rotate(-2deg) translateY(0)}}

    .score-grid{display:grid;gap:12px;grid-template-columns:repeat(2,minmax(0,1fr))}
    @media(min-width:860px){.score-grid{grid-template-columns:repeat(4,minmax(0,1fr))}}
    .stat{border:1px solid var(--panel-border);background:rgba(0,0,0,0.35);border-radius:12px;padding:12px}
    .stat .lbl{font-size:11px;letter-spacing:.2em;text-transform:uppercase;color:rgba(255,255,255,0.6)}
    .stat .val{font-weight:700;font-variant-numeric:tabular-nums;font-size:18px}

    .modal-backdrop{position:fixed;inset:0;background:transparent;backdrop-filter:none;display:flex;align-items:center;justify-content:center;padding:16px;z-index:60}
    .rip-card{background:rgba(255,255,255,0.92);border:1px solid var(--panel-border);border-radius:18px;padding:16px 20px;color:var(--text);max-width:480px;width:100%}
    .close-btn{padding:10px 14px;border-radius:12px;border:1px solid var(--panel-border);background:rgba(124,58,237,0.9);color:white;cursor:pointer}
    .sys-panel{background:#7C3AED;border:2px solid rgba(255,255,255,0.15);border-radius:18px;padding:20px;text-align:center;margin-bottom:16px;animation:wobble 2.4s ease-in-out infinite}
    .down-video{width:min(360px,85vw);max-height:52vh;height:auto;border-radius:18px;display:block;margin:0 auto;object-fit:cover}
    @media(max-width:520px){ .rip-details{ display:none } }

    /* Stress animation for the whole board when down */
    .stress {
      animation: stressShake 0.2s ease-in-out 0s 20;
      /* 0.1s * 20 = 2s total duration, then animation stops */
    }
    @keyframes stressShake{
      0%{ transform:translate(0,0) rotate(0deg) }
      15%{ transform:translate(-2px,1px) rotate(-0.3deg) }
      30%{ transform:translate(2px,-1px) rotate(0.2deg) }
      45%{ transform:translate(-1px,2px) rotate(0.1deg) }
      60%{ transform:translate(1px,-2px) rotate(-0.2deg) }
      75%{ transform:translate(-1px,1px) rotate(0.2deg) }
      100%{ transform:translate(0,0) rotate(0deg) }
    }
    /* Darken background during stress, keep darker after */
    .page{ transition: background .25s ease }
    .page.down{ 
      background: #9f79e6; 
      transition: background 1.5s ease-out; /* Slow fade out */
    }
    .page.down.stress{ 
      background:#201225;
      transition: background .1s ease-in; /* Fast fade in */
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React + ReactDOM + Babel -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Supabase JS v2 UMD build (exposes window.supabase) -->
  <script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js"></script>

  <script type="text/babel" data-presets="env,react">
    const { useState, useEffect, useMemo, useRef } = React;
    // Supabase client (set your values below)
    const SUPABASE_URL = 'https://kizmpecnfzbjwkpwrttg.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imtpem1wZWNuZnpiandrcHdydHRnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk5NDAwOTgsImV4cCI6MjA3NTUxNjA5OH0.RQfXuzOCzFIK_YghjWhvn-eINzPzscH0EbiLdV1RmNw';
    // OPTIONAL: Slack Incoming Webhook URL (for quick prototype). Replace with your real webhook URL.
    // Note: Putting this in a public page exposes the URL; rotate it later or move to a serverless function.
    const SLACK_WEBHOOK_URL = '';
    const supabase = (window.supabase && window.supabase.createClient && SUPABASE_URL.startsWith('https'))
      ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
      : null;

    const STORAGE_KEYS = {
      lastOutageTs: "bp_last_outage_ts",
      streaks: "bp_uptime_streaks",
      isDown: "bp_is_down",
    };
    
    // Voting system configuration
    const VOTE_THRESHOLD = 2; // Number of people needed to confirm outage
    const VOTE_WINDOW_MS = 10 * 60 * 1000; // 10 minutes in milliseconds
    const now = () => Date.now();
    const getStressDuration = () => {
      // Try to get the CSS variable from the document root
      const root = document.documentElement;
      const duration = getComputedStyle(root).getPropertyValue('--stress-duration');
      if (duration && duration !== '') {
        return parseFloat(duration) * 1000;
      }
      return 2000; // Fallback to 2 seconds
    };
    
    // Generate unique user ID
    function generateUserId() {
      let userId = localStorage.getItem('bp_user_id');
      if (!userId) {
        userId = 'user_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        localStorage.setItem('bp_user_id', userId);
      }
      return userId;
    }
    
    // Check if we have enough votes to make outage global
    async function checkVoteThreshold(userId, timestamp) {
      if (!supabase) {
        console.log('No Supabase connection - treating as local outage');
        return false;
      }
      
      try {
        console.log('Adding vote for user:', userId);
        
        // Add this user's vote
        const { error: insertError } = await supabase.from('outage_votes').insert({
          user_id: userId,
          created_at: new Date(timestamp).toISOString(),
          expires_at: new Date(timestamp + VOTE_WINDOW_MS).toISOString()
        });
        
        if (insertError) {
          console.error('Error inserting vote:', insertError);
          return false;
        }
        
        // Count votes in the last 10 minutes
        const { data: votes, error: selectError } = await supabase
          .from('outage_votes')
          .select('*')
          .gte('created_at', new Date(timestamp - VOTE_WINDOW_MS).toISOString())
          .lte('expires_at', new Date(timestamp + VOTE_WINDOW_MS).toISOString());
        
        if (selectError) {
          console.error('Error selecting votes:', selectError);
          return false;
        }
        
        console.log('Current votes:', votes ? votes.length : 0, 'Threshold:', VOTE_THRESHOLD);
        return votes && votes.length >= VOTE_THRESHOLD;
      } catch (e) {
        console.error('Vote check error', e);
        return false;
      }
    }
    const formatDuration = (ms) => {
      if (ms < 0 || !Number.isFinite(ms)) return "--";
      const s = Math.floor(ms / 1000);
      const days = Math.floor(s / 86400);
      const hrs = Math.floor((s % 86400) / 3600);
      const mins = Math.floor((s % 3600) / 60);
      const secs = s % 60;
      const dd = days > 0 ? days + "d " : "";
      return dd + String(hrs).padStart(2,"0") + ":" + String(mins).padStart(2,"0") + ":" + String(secs).padStart(2,"0");
    };
    const formatDurationLong = (ms) => {
      if (ms == null || !Number.isFinite(ms) || ms < 0) return "--";
      const totalMins = Math.floor(ms / 60000);
      const days = Math.floor(totalMins / 1440);
      const hours = Math.floor((totalMins % 1440) / 60);
      const minutes = totalMins % 60;
      const parts = [];
      if (days > 0) parts.push(`${days} day${days!==1? 's':''}`);
      if (hours > 0) parts.push(`${hours} hour${hours!==1? 's':''}`);
      if (minutes > 0 || parts.length === 0) parts.push(`${minutes} minute${minutes!==1? 's':''}`);
      return parts.join(" ");
    };
    const buttonSubtexts = [
      "Click when the cluster faceplants üòµ‚Äçüí´",
      "The corgies took over",
      "If it's pending, I'm pretending to work",
      "`module load patience` failed",
      "Today I learned: uptime is a myth",
      "HPC? More like Hopefully, Please Compute",
    ];
    const pickNextIndex = (current, length) => {
      if (length <= 1) return current;
      let next = Math.floor(Math.random()*length);
      if (next === current) next = (next+1)%length;
      return next;
    };

    function App(){
      const [lastOutageTs, setLastOutageTs] = useState(() => {
        try { const v = localStorage.getItem(STORAGE_KEYS.lastOutageTs); if (v) return Number(v); } catch {}
        const t = now(); try { localStorage.setItem(STORAGE_KEYS.lastOutageTs, String(t)); } catch {}
        return t;
      });
      const [streaks, setStreaks] = useState(() => {
        try { const raw = localStorage.getItem(STORAGE_KEYS.streaks); return raw ? JSON.parse(raw) : []; } catch { return []; }
      });
      const [isDown, setIsDown] = useState(false);
      const [serverLastRunMs, setServerLastRunMs] = useState(null);

      const [tick, setTick] = useState(0);
      useEffect(() => {
        // Always tick every second so we can count both uptime (not down)
        // and downtime (down) using the same anchor timestamp
        const id = setInterval(() => setTick(t=>t+1), 1000);
        return () => clearInterval(id);
      }, []);
      const elapsedSinceOutage = useMemo(() => (now() - lastOutageTs), [lastOutageTs, tick]);
      const daysSinceLastIssue = useMemo(() => (
        isDown ? 0 : Math.max(0, Math.floor((now() - lastOutageTs) / 86400000))
      ), [isDown, lastOutageTs, tick]); 

      // SLACK INTEGRATION THAT I STILL NEED TO WORK ON   
      async function sendSlackSimple(text){
        if (!SLACK_WEBHOOK_URL || !SLACK_WEBHOOK_URL.startsWith('https://hooks.slack.com/')) return;
        try{
          await fetch(SLACK_WEBHOOK_URL, {
            method: 'POST',
            headers: { 'Content-Type':'application/json' },
            body: JSON.stringify({ text })
          });
        }catch(e){ console.warn('Slack webhook error', e); }
      }

      // --- Supabase sync ---
      useEffect(() => {
        if (!supabase) return;
        let channel;
        async function computeServerLastRun(){
          try{
            const { data: latestStart, error: e1 } = await supabase
              .from('outages')
              .select('started_at')
              .order('started_at', { ascending:false })
              .limit(1)
              .single();
            const { data: latestEnded, error: e2 } = await supabase
              .from('outages')
              .select('ended_at')
              .gt('ended_at', 0)
              .order('ended_at', { ascending:false })
              .limit(1)
              .single();
            if (e1 || e2 || !latestStart || !latestEnded){ setServerLastRunMs(null); return; }
            const startMs = Number(latestStart.started_at);
            const endedMs = Number(latestEnded.ended_at);
            const ms = startMs - endedMs;
            setServerLastRunMs(Number.isFinite(ms) && ms > 0 ? ms : null);
          }catch{ setServerLastRunMs(null); }
        }
        (async () => {
          // Ensure singleton status row exists
          const { data, error } = await supabase
            .from('status')
            .select('*')
            .eq('id', 1)
            .single();
          if (!data) {
            await supabase.from('status').upsert({ id: 1, is_down: false, last_outage_ts: now() }, { onConflict: 'id' });
          } else {
            console.log('Initial sync: setting isDown to', Boolean(data.is_down));
            setIsDown(Boolean(data.is_down));
            setLastOutageTs(Number(data.last_outage_ts) || now());
            setShowRIP(Boolean(data.is_down));
          }
          await computeServerLastRun();
          // Realtime subscription for status changes
          channel = supabase
            .channel('public:status')
            .on('postgres_changes', { event: '*', schema: 'public', table: 'status', filter: 'id=eq.1' }, (payload) => {
              const row = payload.new || payload.old;
              if (!row) return;
              
              // Don't override local outages with real-time sync
              if (ignoreRealtimeSyncRef.current) {
                console.log('Ignoring real-time sync - local outage in progress');
                return;
              }
              
              console.log('Real-time sync: setting isDown to', Boolean(row.is_down));
              setIsDown(Boolean(row.is_down));
              setLastOutageTs(Number(row.last_outage_ts) || now());
              setShowRIP(Boolean(row.is_down));
            })
            .on('postgres_changes', { event: '*', schema: 'public', table: 'outages' }, () => { computeServerLastRun(); })
            .subscribe();
        })();
        return () => { if (channel) supabase.removeChannel(channel); };
      }, []);

      // Clean up expired votes every minute
      useEffect(() => {
        if (!supabase) return;
        
        const cleanup = setInterval(async () => {
          try {
            await supabase
              .from('outage_votes')
              .delete()
              .lt('expires_at', new Date().toISOString());
          } catch (e) {
            console.warn('Vote cleanup error', e);
          }
        }, 60000); // Every minute
        
        return () => clearInterval(cleanup);
      }, []);

      // Fallback polling: keep clients in sync even if Realtime isn't firing
      useEffect(() => {
        if (!supabase) return;
        let cancelled = false;
        async function fetchStatus(){
          try{
            const { data } = await supabase
              .from('status')
              .select('*')
              .eq('id', 1)
              .single();
            if (!cancelled && data){
              // Don't override local outages with polling
              if (ignoreRealtimeSyncRef.current) {
                console.log('Ignoring polling sync - local outage in progress');
                return;
              }
              
              console.log('Polling sync: setting isDown to', Boolean(data.is_down));
              setIsDown(Boolean(data.is_down));
              setLastOutageTs(Number(data.last_outage_ts) || now());
              setShowRIP(Boolean(data.is_down));
            } else if (!cancelled) {
              console.warn('Polling: no status row found');
            }
          }catch(e){ console.warn('Polling fetchStatus error', e); }
        }
        const id = setInterval(fetchStatus, 5000); // Reduce polling frequency
        // immediate sync on mount
        fetchStatus();
        return () => { cancelled = true; clearInterval(id); };
      }, []);

      async function dbMarkDown(startTs){
        if (!supabase) return;
        try {
          const { data: inserted, error: insErr } = await supabase
            .from('outages')
            .insert({ started_at: startTs, ended_at: null, uptime_ms: 0 })
            .select('id')
            .single();
          if (!insErr && inserted && inserted.id != null) {
            pendingOutageIdRef.current = inserted.id;
          }
        } catch (e) { console.warn('Supabase outages insert error', e); }
        try {
          await supabase.from('status').upsert({ id:1, is_down:true, last_outage_ts:startTs }, { onConflict:'id' });
        } catch (e) { console.warn('Supabase status upsert (down) error', e); }
        const when = new Date(startTs).toLocaleString();
        sendSlackSimple(`:rotating_light: BP WENT DOWN at ${when}`);
      }
      async function dbMarkUp(endTs){
        if (!supabase) return;
        try {
          await supabase.rpc('close_latest_outage', { p_end_ts: endTs });
        } catch (e) { console.warn('Supabase close_latest_outage error', e); }
        try {
          await supabase.from('status').upsert({ id:1, is_down:false, last_outage_ts:endTs }, { onConflict:'id' });
        } catch (e) { console.warn('Supabase status upsert (up) error', e); }
        const when = new Date(endTs).toLocaleString();
        sendSlackSimple(`:white_check_mark: BP is performative again at ${when}`);
      }

      const stats = useMemo(() => {
        if (!streaks.length) return { max:0, mean:0, median:0, count:0 };
        const arr = [...streaks.map(s=>s.uptimeMs)].sort((a,b)=>a-b);
        const sum = arr.reduce((a,b)=>a+b,0);
        const mid = Math.floor(arr.length/2);
        const median = arr.length%2 ? arr[mid] : (arr[mid-1]+arr[mid])/2;
        return { max: Math.max(...arr), mean: sum/arr.length, median, count: arr.length };
      }, [streaks]);
      const lastRunMs = useMemo(() => {
        if (!streaks || streaks.length === 0) return null;
        const v = Number(streaks[0]?.uptimeMs);
        return Number.isFinite(v) && v > 0 ? v : null;
      }, [streaks]);
      const effectiveLastRunMs = serverLastRunMs ?? lastRunMs;

      function persist(lastTs, list, down = isDown){
        try{
          localStorage.setItem(STORAGE_KEYS.lastOutageTs, String(lastTs));
          localStorage.setItem(STORAGE_KEYS.streaks, JSON.stringify(list));
          localStorage.setItem(STORAGE_KEYS.isDown, String(down));
        }catch{}
      }

      // sound
      const [isMuted, setIsMuted] = useState(true); /* The sound of the button when it is not pressed. Default is muted. */
      const audioCtxRef = useRef(null);
      function ensureCtx(){
        if(!audioCtxRef.current){
          const AC = window.AudioContext || window.webkitAudioContext;
          if (AC) audioCtxRef.current = new AC();
        }
        const ctx = audioCtxRef.current;
        if (ctx && ctx.state === 'suspended') {
          try { ctx.resume(); } catch {}
        }
        return ctx;
      }
      // Attempt to unlock audio on first user gesture (mobile Safari, etc.)
      useEffect(() => {
        const unlock = () => { const ctx = ensureCtx(); if (ctx && ctx.state === 'suspended') { try{ ctx.resume(); }catch{} } };
        window.addEventListener('pointerdown', unlock, { once:true });
        window.addEventListener('touchstart', unlock, { once:true });
        return () => {
          window.removeEventListener('pointerdown', unlock);
          window.removeEventListener('touchstart', unlock);
        };
      }, []);
      function playThock(){
        if (isMuted) return;
        const ctx = ensureCtx(); if (!ctx) return; if (ctx.state==='suspended') { try{ ctx.resume(); }catch{} }
        const o = ctx.createOscillator(), g = ctx.createGain();
        o.type="square"; o.frequency.setValueAtTime(140, ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(90, ctx.currentTime+0.06);
        g.gain.setValueAtTime(0.0001, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.3, ctx.currentTime+0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.09);
        o.connect(g).connect(ctx.destination); o.start(); o.stop(ctx.currentTime+0.12);
      }
      function playFlatline(){
        if (isMuted) return;
        const ctx = ensureCtx(); if (!ctx) return; if (ctx.state==='suspended') { try{ ctx.resume(); }catch{} }
        const o = ctx.createOscillator(), g = ctx.createGain();
        o.type="sine"; o.frequency.setValueAtTime(880, ctx.currentTime);
        g.gain.setValueAtTime(0.0001, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.22, ctx.currentTime+0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.18);
        o.connect(g).connect(ctx.destination); o.start(); o.stop(ctx.currentTime+0.2);
      }

      // press feel
      const [pressed, setPressed] = useState(false);
      const [pressDepth, setPressDepth] = useState(0);
      const pressTimer = useRef(null);
      const [subtextIndex, setSubtextIndex] = useState(0);
      const [showRIP, setShowRIP] = useState(false);
      const [isStressed, setIsStressed] = useState(false);
      const [isLocalOutage, setIsLocalOutage] = useState(false);
      const [ignoreRealtimeSync, setIgnoreRealtimeSync] = useState(false);
      const ignoreRealtimeSyncRef = useRef(false);
      const [videoOk, setVideoOk] = useState(true);
      const downVideoRef = useRef(null);
      const btnRef = useRef(null);
      const prevLastOutageTsRef = useRef(null);
      const prevStreaksRef = useRef(null);
      const accidentalStartRef = useRef(null);
      const pendingOutageIdRef = useRef(null);
      const startedAtIsoRef = useRef(null);

      function chooseNextQuote(){ setSubtextIndex(idx => pickNextIndex(idx, buttonSubtexts.length)); }

      function startPress(){
        if (isDown) return;
        setPressed(true); chooseNextQuote(); playThock();
        const start = performance.now(), dur = 90, from = pressDepth;
        const step = (t)=>{ const k = Math.min(1,(t-start)/dur); setPressDepth(from + (1-from)*k); if (k<1) pressTimer.current=requestAnimationFrame(step); };
        pressTimer.current = requestAnimationFrame(step);
      }
      function endPress(){
        if (pressTimer.current) cancelAnimationFrame(pressTimer.current);
        pressTimer.current = null; setPressed(false);
        const start = performance.now(), dur = 180, from = pressDepth;
        const step = (t)=>{ const k = Math.min(1,(t-start)/dur); setPressDepth(from*(1-k)); if (k<1) requestAnimationFrame(step); };
        requestAnimationFrame(step);
      }

      // Global keyboard: Enter triggers the outage button anywhere; Space disabled on button only
      useEffect(() => {
        const isTypingTarget = (el) => {
          if (!el) return false;
          const tag = el.tagName;
          return tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable;
        };
        const onKeyDown = (e) => {
          if (isTypingTarget(e.target)) return;
          if (e.key === 'Enter') { 
            e.preventDefault(); 
            if (isDown) {
              setIsStressed(true);
              setTimeout(() => setIsStressed(false), getStressDuration());
            } else {
              startPress(); 
            }
          }
        };
        const onKeyUp = (e) => {
          if (isTypingTarget(e.target)) return;
          if (e.key === 'Enter') { 
            e.preventDefault(); 
            if (!isDown) {
              endPress(); 
              handleOutagePress(); 
            }
          }
        };
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        return () => {
          window.removeEventListener('keydown', onKeyDown);
          window.removeEventListener('keyup', onKeyUp);
        };
      }, [isDown, showRIP]);

      function spawnRipple(){
        const host = btnRef.current;
        if (!host) return;
        const r = document.createElement('span');
        r.className = 'ripple';
        host.appendChild(r);
        r.addEventListener('animationend', () => r.remove(), { once:true });
      }

      async function handleOutagePress(){
        if (isDown) return;
        console.log('Button pressed - starting outage process');
        
        const t = now();
        const userId = generateUserId();
        console.log('Generated user ID:', userId);
        
        // Check if we should make it global
        const shouldGoGlobal = await checkVoteThreshold(userId, t);
        console.log('Should go global:', shouldGoGlobal);
        
        prevLastOutageTsRef.current = lastOutageTs;
        prevStreaksRef.current = streaks;
        accidentalStartRef.current = t;
        const uptimeMs = t - lastOutageTs;
        const newEntry = { startedAt:lastOutageTs, endedAt:t, uptimeMs };
        const next = [newEntry, ...(streaks||[])].slice(0,1000);
        
        console.log('Setting local state - outage should be visible now');
        setStreaks(next); 
        setLastOutageTs(t); 
        setShowRIP(true); 
        setIsDown(true);
        setIsStressed(true);
        setTimeout(() => setIsStressed(false), getStressDuration());
        playFlatline();
        persist(t, next, true);
        
        if (shouldGoGlobal) {
          // Global outage - affects everyone and sends Slack notification
          console.log('Making outage global');
          setIsLocalOutage(false);
          setIgnoreRealtimeSync(false); // Allow real-time sync for global outages
          dbMarkDown(t);
        } else {
          // Local outage - only affects this user, no Slack notification
          console.log('Keeping outage local - waiting for more votes');
          setIsLocalOutage(true);
          setIgnoreRealtimeSync(true); // Prevent real-time sync from overriding local outage
          ignoreRealtimeSyncRef.current = true; // Set ref immediately
          console.log('Set ignoreRealtimeSync to true');
        }
      }

      function closeRIP(){
        console.log('Closing RIP - re-enabling real-time sync');
        setShowRIP(false); 
        setIsDown(false);
        setIsLocalOutage(false);
        setIgnoreRealtimeSync(false); // Re-enable real-time sync
        ignoreRealtimeSyncRef.current = false; // Reset ref immediately
        const t = now();
        setLastOutageTs(t);
        persist(t, streaks, false);
        dbMarkUp(t);
      }

      async function undoAccident(){
        // Revert local state and remote records for a false alarm
        const prevTs = prevLastOutageTsRef.current;
        const prevList = Array.isArray(prevStreaksRef.current) ? prevStreaksRef.current : streaks;
        const startTs = accidentalStartRef.current;
        setShowRIP(false);
        setIsDown(false);
        if (prevTs != null) setLastOutageTs(prevTs);
        setStreaks(prevList || []);
        persist(prevTs ?? lastOutageTs, prevList || [], false);
        if (supabase) {
          try {
            if (pendingOutageIdRef.current != null) {
              await supabase.from('outages').delete().eq('id', pendingOutageIdRef.current);
            } else if (startTs != null) {
              await supabase.from('outages').delete().eq('started_at', startTs).is('ended_at', null);
            }
          } catch(e){ console.warn('Supabase undo delete outage error', e); }
          try { await supabase.from('status').upsert({ id:1, is_down:false, last_outage_ts: (prevTs ?? lastOutageTs) }, { onConflict:'id' }); } catch(e){ console.warn('Supabase undo status upsert error', e); }
        }
        sendSlackSimple(':warning: False alarm cancelled ‚Äî metrics preserved.');
        pendingOutageIdRef.current = null;
        startedAtIsoRef.current = null;
        accidentalStartRef.current = null;
      }

      // When popup opens or mute state changes, try to play video with sound unless muted
      useEffect(() => {
        if (!showRIP) return;
        const v = downVideoRef.current;
        if (!v) return;
        try{
          v.muted = isMuted;
          v.currentTime = 0;
          const p = v.play();
          if (p && p.catch) {
            p.catch(async () => {
              // If autoplay with sound is blocked, fallback to muted autoplay
              if (!isMuted) {
                v.muted = true;
                try { await v.play(); } catch {}
              }
            });
          }
        }catch{}
      }, [showRIP, isMuted]);

      const quips = [
        "Remember to `git stash` before the storm.",
        "Have you tried turning the cluster off and on again? (‚Ä¶wait)",
        "SLURM says: PENDING. You say: ‚òï",
        "`nvidia-smi`: Not Found. Your sanity: Also not found.",
        "Today‚Äôs standup: We stood up. BP didn‚Äôt.",
        "PBS vs SLURM cage match when?",
        "Error: Confidence not found (code 503)",
      ];
      const quip = useMemo(()=>quips[Math.floor(Math.random()*quips.length)], [tick%60]);

      return (
        <div className={`page ${isDown ? 'down' : ''} ${isStressed ? 'stress' : ''}`}>
          {/* Happy ASCII background when not down (light, looping) */}
          {!isDown && (
            <div className="ascii-bg" aria-hidden>
              <div className="ascii-tiles">
                {Array.from({length:48}).map((_,i)=> (
                  <pre key={i} className="ascii-tile">{`
  ____________      ____________
 |  Node ${String.fromCharCode(65+(i%26))}   |_____/   Node ${String.fromCharCode(66+(i%26))}   |
 |  [::]  :)|     |   [::]  :) |
 |__________|     |_____________|
     |   |             |   |
  ___|___|___      ____|___|____
 |  STORAGE  |-->  |  SCHEDULER  |
 |  [ OK ]   |     |   [ OK ]    |
 |___________|     |_____________|
`}</pre>
                ))}
              </div>
            </div>
          )}
          
          {/* Broken ASCII background when down (dark, glitchy) */}
          {isDown && (
            <div className="ascii-broken" aria-hidden>
              <div className="ascii-broken-tiles">
                {Array.from({length:48}).map((_,i)=> (
                  <pre key={i} className="ascii-broken-tile">{`
  ____________      ____________
 |  Node ${String.fromCharCode(65+(i%26))}   |_____/   Node ${String.fromCharCode(66+(i%26))}   |
 |  [XX]  :(|     |   [XX]  :( |
 |__________|     |_____________|
     |   |             |   |
  ___|___|___      ____|___|____
 |  STORAGE  |-->  |  SCHEDULER  |
 |  [FAIL]   |     |   [FAIL]    |
 |___________|     |_____________|
`}</pre>
                ))}
              </div>
            </div>
          )}
          
          {/* Banner */}
          <div className="banner">
            <div className="container">
              <div className="card" style={{position:'relative', display:'flex', alignItems:'center', justifyContent:'space-between', flexWrap:'wrap', gap: '24px 0'}}>
                <div style={{minWidth:200}}>
                  <div className="hush" style={{marginBottom:6}}>Days since last BP issue</div>
                  <div className="time" style={{fontSize:'clamp(22px,4vw,48px)'}} aria-live="polite">{String(daysSinceLastIssue)}</div>
                </div>
                <div>
                  <div className="hush">{isDown ? 'Time BP is down' : 'Time since BP went down'}</div>
                  <div className="time" aria-live="polite">{formatDuration(elapsedSinceOutage)}</div>
                </div>
                <div style={{display:'flex', alignItems:'center', gap:16}}>
                  <div style={{
                    background: 'var(--purple-600)',
                    color: 'white',
                    borderRadius: '12px',
                    padding: '18px 28px',
                    fontWeight: 800,
                    fontSize: 'clamp(22px,3vw,32px)',
                    boxShadow: '0 2px 16px 0 rgba(124,58,237,0.18)',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    minWidth: '180px'
                  }}>
                    <span style={{fontSize:'13px',letterSpacing:'.12em',textTransform:'uppercase',opacity:0.82,marginBottom:2}}>Last Outage</span>
                    <span style={{fontSize:'clamp(16px,2vw,20px)',fontWeight:700,marginBottom:2}}>
                      {new Date(lastOutageTs).toLocaleDateString()}
                    </span>
                    <span style={{fontSize:'clamp(15px,2vw,18px)',fontWeight:500,opacity:0.92}}>
                      {new Date(lastOutageTs).toLocaleTimeString()}
                    </span>
                    <span style={{fontSize:'12px',marginTop:6,opacity:0.85,display:'block',textTransform:'uppercase',letterSpacing:'.12em'}}>Last run</span>
                    <span style={{fontSize:'clamp(14px,2vw,16px)',fontWeight:600}}>
                      {effectiveLastRunMs == null ? '‚Äî' : formatDurationLong(effectiveLastRunMs)}
                    </span>
                    <span style={{fontSize:'13px',marginTop:6,opacity:0.7}}>
                      {(() => {
                        const msAgo = now() - lastOutageTs;
                        if (msAgo < 0 || !Number.isFinite(msAgo)) return "--";
                        const s = Math.floor(msAgo / 1000);
                        const days = Math.floor(s / 86400);
                        const hrs = Math.floor((s % 86400) / 3600);
                        let str = [];
                        if (days > 0) str.push(`${days}d`);
                        if (hrs > 0 || days > 0) str.push(`${hrs}h`);
                        if (s < 60) return "Just now";
                        return str.length ? str.join(' ') + " ago" : "Just now";
                      })()}
                    </span>
                  </div>
                  {/* Mute button moved to page bottom */}
                </div>
              </div>
            </div>
          </div>

          {/* Center */}
          <div className="center">
            <div className="socket" style={{padding:0,margin:0,background:'transparent',border:'none',boxShadow:'none'}}>
              <button
                ref={btnRef}
                className={`btn-wrap ${pressed ? 'btn-press' : 'btn-normal'} ${isDown ? 'button-disabled' : ''}`}
                onMouseDown={() => { if (!isDown) startPress(); }}
                onMouseUp={() => { if (!isDown) endPress(); }}
                onMouseLeave={() => { if (!isDown) endPress(); }}
                onClick={() => { if (!isDown) handleOutagePress(); }}
                onKeyDown={(e) => { if (e.key === ' ' || e.code === 'Space' || e.key === 'Spacebar') { e.preventDefault(); } }}
                onKeyUp={(e) => { if (e.key === ' ' || e.code === 'Space' || e.key === 'Spacebar') { e.preventDefault(); } }}
                disabled={isDown}
                aria-disabled={isDown}
              >
                 <div className="btn-shine" style={{opacity: pressed ? 0.15 : 0.35, background:'linear-gradient(to bottom, rgba(255,255,255,0.25), rgba(255,255,255,0))'}}></div>
                <div
                  className="btn-cap"
                  style={{
                    transform: pressed ? 'translateY(2px) scale(0.985)' : 'translateY(0) scale(1)',
                    boxShadow: pressed ? 'inset 0 8px 18px rgba(0,0,0,0.35)' : 'inset 0 3px 6px rgba(255,255,255,0.12)'
                  }}
                >
                  <span style={{fontSize:'clamp(24px,4vw,24px)', textAlign:'center', lineHeight:'1.2'}}>BP<br/>WENT<br/>DOWN <br/> !!!</span>
                </div>
                <div className="subtext">{buttonSubtexts[subtextIndex]}</div>
              </button>
            </div>
          </div>

          {/* Scoreboard commented out by request */}
          {false && (
            <div className="container" style={{paddingBottom:56}}>
              <div className="card" style={{cursor:'pointer'}} onClick={()=>alert('Open: History & Hall of Fame (trimmed in single-file build)')}>
                <div style={{display:'flex',alignItems:'center',justifyContent:'space-between',gap:8,flexWrap:'wrap'}}>
                  <div>
                    <div className="hush">Scoreboard</div>
                    <div style={{fontSize:18,color:'rgba(0,0,0,.7)'}}>Click to open history & hall of fame</div>
                  </div>
                  <div className="score-grid" style={{width:'100%',maxWidth:640}}>
                    <div className="stat"><div className="lbl">Longest uptime</div><div className="val">{formatDuration(stats.max)}</div></div>
                    <div className="stat"><div className="lbl">Median uptime</div><div className="val">{formatDuration(stats.median)}</div></div>
                    <div className="stat"><div className="lbl">Average uptime</div><div className="val">{formatDuration(stats.mean)}</div></div>
                    <div className="stat"><div className="lbl">Outages logged</div><div className="val">{String(stats.count)}</div></div>
                  </div>
                </div>
                <div className="muter" style={{marginTop:12,color:'rgba(0,0,0,.55)'}}>{quip}</div>
              </div>
            </div>
          )}

          {/* RIP Popup */}
          {showRIP && (
            <div className="modal-backdrop popup-enter">
              <div className="rip-card">
                <div style={{fontWeight:800,fontSize:22,marginBottom:12}}>
                  Big Purple is down RIP üíÄ
                  {isLocalOutage && (
                    <div style={{fontSize:14,color:'#ff6b6b',marginTop:4}}>
                      ‚ö†Ô∏è Local outage - waiting for {VOTE_THRESHOLD - 1} more vote(s) to go global
                    </div>
                  )}
                </div>
                <div style={{margin:'0 auto',width:360,maxWidth:'100%'}}>
                  <div className="sys-panel" style={{padding:0, background:'transparent', border:'none'}}>
                    {/* Down-state media with GIF fallback; ensure autoplay on mobile */}
                    {videoOk ? (
                      <video ref={downVideoRef} className="down-video" autoPlay={true} muted={false} loop={true} playsInline={true} onError={()=>setVideoOk(false)} preload="auto">
                        <source src="bp-down.MP4" type="video/mp4" />
                      </video>
                    ) : (
                      <img className="down-video" src="bp-down.gif" alt="BP down" />
                    )}
                    <div className="rip-details" style={{padding:'10px 16px'}}>
                      <div style={{fontSize:'24px',fontWeight:'bold'}}>SYSTEM DOWN</div>
                      <div style={{fontSize:'14px',opacity:0.9,marginTop:'8px'}}>
                        ‚ùå GPU Queue: OFFLINE<br/>
                        ‚ùå Compute Nodes: UNAVAILABLE<br/>
                        ‚ùå Your Sanity: NOT FOUND !!!
                      </div>
                    </div>
                  </div>
                </div>
                <div style={{marginTop:16,textAlign:'center',color:'rgba(0,0,0,.7)',fontStyle:'italic'}}>
                  {/* style must be an object in JSX */}
                  {"Tell my jobs‚Ä¶ they were "}<span style={{ textDecoration: 'line-through' }}>pending</span>{" loved. ‚Äî Big Purple"}
                </div>
                <div style={{marginTop:20,display:'flex',flexDirection:'column',alignItems:'center',gap:8}}>
                  <button className="close-btn" onClick={closeRIP}>I'm performative again</button>
                  <button className="close-btn" style={{background:'rgba(255,255,255,0.95)',color:'var(--text)'}} onClick={undoAccident}>Accident ‚Äî don't reset</button>
                </div>
              </div>
            </div>
          )}
          {/* Bottom controls */}
          <div style={{position:'fixed',bottom:16,left:16,zIndex:80,display:'flex',gap:8}}>
            <button className="pill" onClick={()=>setIsMuted(m=>!m)}>{isMuted ? "Unmute" : "Mute"}</button>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
